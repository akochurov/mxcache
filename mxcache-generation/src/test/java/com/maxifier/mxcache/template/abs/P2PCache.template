package com.maxifier.mxcache.impl.caches.abs;

import com.maxifier.mxcache.CacheFactory;
import com.maxifier.mxcache.caches.*;
import com.maxifier.mxcache.impl.MutableStatistics;
import com.maxifier.mxcache.impl.CacheId;
import com.maxifier.mxcache.impl.CalculatableHelper;
import com.maxifier.mxcache.impl.resource.*;
import com.maxifier.mxcache.provider.CacheDescriptor;
import com.maxifier.mxcache.storage.*;

import org.jetbrains.annotations.NotNull;

/**
 * Project: Maxifier
 * Created by: Yakoushin Andrey
 * Date: 15.02.2010
 * Time: 13:54:51
 * <p/>
 * Copyright (c) 1999-2009 Magenta Corporation Ltd. All Rights Reserved.
 * Magenta Technology proprietary and confidential.
 * Use is subject to license terms.
 *
 * @author ELectronic ENgine
 */
public abstract class Abstract#EG##FG#Cache extends AbstractCache implements #EG##FG#Cache, #EG##FG#Storage {
    private final #EG##FG#Calculatable calculatable;

    @NotNull
    private final DependencyNode node;

    private final Object owner;

    public Abstract#E##F#Cache(Object owner, #EG##FG#Calculatable calculatable, @NotNull DependencyNode node, MutableStatistics statistics) {
        super(statistics);
        this.node = node;
        this.owner = owner;
        this.calculatable = calculatable;
    }

    @Override
    public #fg# getOrCreate(#IF_E##eg# o#ENDIF#) {
        lock();
        try {
            if (isCalculated(#IF_E#o#ENDIF#)) {
                DependencyTracker.mark(node);
                hit();
                return load(#IF_E#o#ENDIF#);
            }
            DependencyNode callerNode = DependencyTracker.track(node);
            try {
                while(true) {
                    try {
                        return create(#IF_E#o#ENDIF#);
                    } catch (ResourceOccupied e) {
                        if (callerNode != null) {
                            throw e;
                        } else {
                            unlock();
                            try {
                                e.getResource().waitForEndOfModification();
                            } finally {
                                lock();
                            }
                            if (isCalculated(#IF_E#o#ENDIF#)) {
                                hit();
                                return load(#IF_E#o#ENDIF#);
                            }
                        }
                    }
                }
            } finally {
                DependencyTracker.exit(callerNode);
            }
        } finally {
            unlock();
        }
    }

    private #fg# create(#IF_E##eg# o#ENDIF#) {
        long start = System.nanoTime();
        #fg# t = calculatable.calculate(owner#IF_E#, o#ENDIF#);
        long end = System.nanoTime();
        miss(end - start);
        save(#IF_E#o, #ENDIF#t);
        return t;
    }

    @Override
    public CacheDescriptor getDescriptor() {
        CacheId id = CalculatableHelper.getId(calculatable.getClass());
        return CacheFactory.getProvider().getDescriptor(id);
    }

    @Override
    public DependencyNode getDependencyNode() {
        return node;
    }

    @Override
    public String toString() {
        return getDescriptor() + ": " + owner;
    }
}